using System;

namespace ProjectEulerCS {
  class Problem37 {
    // Find the sum of all eleven primes that are both truncatable from left to right and right to left.
    //
    // The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove
    // digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work
    // from right to left: 3797, 379, 37, and 3.
    //
    // Find the sum of the only eleven primes that are both truncatable from left to right and right to left.
    //
    // NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.


    // I don't like any of the code from my normal sources. But Math Blog points me to a Python solution that
    // is interesting.


    // From http://blog.dreamshire.com/2009/04/23/project-euler-problem-37-solution/:
    // When a prime number, greater than 100, is truncated, it can’t be composed of any digits from the set
    // {2, 4, 5, 6, 8, 0} or the truncated number would be composite. Further, it can’t start or end with 1 or 9
    // or a truncated version would end up being composite. Finally, any prime having pairs as ’11′, ’33′, ’77′
    // or ’99′ would eventually be divisible by 11 and therefore composite.
    //
    // By applying this observation, we could truncate(sorry) our original list of primes from 78,473 to 65
    // primes. After looking at the list you immediately see you could eliminate entries ending in 93 or
    // beginning with 39 leaving only 40 primes left to check. You could keep going and easily solve this one by
    // hand.
    
    private static int[] ps = Ancillary.ESieve(1000000);

    private static bool isPrime(int n) {
      return Array.BinarySearch(ps, n) > 0;
    }


    // This list of primes was generated by the regex
    // @p = grep {!/[024568]/ && !/99|77|33|11/ && !/^[91]/ && !/[91]$/ && !/93$/ && !/^39/} @primes;
    // with the additional comment:
    // We didn’t forget to add the two-digit truncatable primes. We found them by hand: 23, 37, 53, 73.
    private static int[] primes = {23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797, 7937, 31397, 31973,
                                   37313, 37397, 71317, 71713, 71917, 73973, 79397, 313717, 317197,
                                   319313, 371737, 371797, 373717, 373937, 379397, 713737, 713917,
                                   717317, 717397, 717917, 719197, 719713, 719717, 731713, 731737,
                                   739373, 739397, 791317, 791797, 793717, 797917};
    
    // Based on http://blog.dreamshire.com/2009/04/23/project-euler-problem-37-solution/:

    private static bool trunc(int n) {
      int c = n;

      while (c>10) {
        c = c % (int)(Math.Pow((double)10, (double)(int)Math.Log10((double)c)));
        n /= 10;
        if (!isPrime(c) || !isPrime(n)) return false;
      }

      return true;
    }

    private static int getAnswer() {
      int s = 0, c = 0;

      foreach (int p in primes)
        if (trunc(p)) {
          s += p;
          c++;
        }

      return s; // 748294. Correct answer is 748317. A difference of 23. How am I missing the first one?
    }

    public static int Answer {
      get { return getAnswer(); }
    }
  }
}

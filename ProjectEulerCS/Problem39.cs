using System;
using System.Collections.Generic;
using System.Linq;

namespace ProjectEulerCS {
  class Problem39 {
    // If p is the perimeter of a right angle triangle, {a, b, c}, which value, for p ≤ 1000, has the most
    // solutions?
    //
    // If p is the perimeter of a right angle triangle with integral length sides, {a,b,c}, there are exactly
    // three solutions for p = 120.
    //
    // {20,48,52}, {24,45,51}, {30,40,50}
    //
    // For which value of p ≤ 1000, is the number of solutions maximised?

    private static bool isRightTriangle(int a, int b, int c) {
      return a*a + b*b == c*c;
    }

    private static int perimeter(Tuple<int, int, int> triangle) {
      return triangle.Item1 + triangle.Item2 + triangle.Item3;
    }

    /// <summary>
    /// Returns Pythagorean Triplets up to limit generated by brute force algorithm.
    /// </summary>
    private static IEnumerable<Tuple<int, int, int>> pythagoreanTriplets(int limit) {
      for (int a=1; a<1000; a++)
        for (int b=a; b<1000; b++)
          for (int c=b; c<1000; c++)
            if (isRightTriangle(a,b,c))
              yield return new Tuple<int,int,int>(a,b,c);
    }

    private static int getAnswer() {
      var ts = pythagoreanTriplets(1000);
      var ps = ts.GroupBy(perimeter);        // In C# the GroupBy() function returns an IGrouping. That sucks.
      var gs = ps.Where(g => g.Key <= 1000); // Why can't it just return a List<int, Tuple<int,int,int>> like F#?
      
      // This sucks.
      int maxCount = 0;
      int p = 0;

      foreach (IGrouping<int,Tuple<int,int,int>> g in gs) { // Having to declare the type of g sucks, too.
        int c = g.Count();

        if (c>maxCount) {
          maxCount = c;
          p = g.Key;
        }
      }

      return p; // 840.
    }


    // Based on http://www.mathblog.dk/project-euler-39-perimeter-right-angle-triangle/:

    private static bool bIsIntegral(int p, int a) {
      // This equation comes from combining a*a + b*b = c*c and a+b+c=p and then isolating b.

      return p*(p-2*a) % (2*(p-a)) == 0;
    }

    private static int getAnswer1() {
      // This is the arithmetic solution Math Blog offers in contrast to the Brute Force or
      // Number Theoretical solutions. After about half a day's study, I can follow it enough
      // to feel justified in including it in my own code!

      int result = 0, resultSolution = 0;

      for (int p=2; p<1001; p+=2) {
        int solutionsCount = 0;

        for (int a=2; a<p/3; a++)
          if (bIsIntegral(p,a))
            solutionsCount++;

        if (solutionsCount>resultSolution) {
          resultSolution = solutionsCount;
          result = p;
        }
      }

      return result; // 840.
    }

    public static int Answer {
      get { return getAnswer1(); }
    }
  }
}
